Day 3月22日:
媒体内容统一提取API开发进度报告
需求背景
用户需要一个统一的API端口，能够处理来自不同社交媒体平台的视频内容。具体要求包括：

接收视频URL作为输入参数
自动识别并分别处理抖音和小红书平台的内容
对抖音视频使用现有的抖音服务获取内容
对小红书视频先以mock数据方式返回，为未来实现做准备
返回格式统一的结构化数据，包含丰富的视频元数据
今日讨论内容
确定了统一API的设计原则和数据模型
讨论了各平台自动识别的实现方式
确定了丰富的返回数据结构，包含：
视频基本信息：标题、描述、原始URL等
视频标签
作者详细信息：包括ID、昵称、签名、粉丝数等
统计数据：点赞数、评论数、收藏数等
媒体信息：封面、视频URL、时长等
确认了需要在响应中包含请求上下文信息
决定优先复用现有架构和组件，保持系统一致性
今日完成进度
需求分析和API设计
完成了统一内容提取API的详细设计
定义了请求参数和响应数据模型
确定了自动平台识别和处理策略
核心组件开发
实现了响应数据模型（MediaContentResponse等）
开发了统一媒体服务类（MediaService）
创建了API路由处理器（/api/media/extract）
系统集成
将新功能集成到现有项目架构中
复用了授权验证、日志系统等基础组件
利用现有的DouyinService处理抖音内容
实现了小红书内容的mock数据返回
测试与调试
编写了API测试命令
解决了API路径前缀问题
下一步计划
小红书内容的实际提取功能实现
扩展支持更多媒体平台
增强错误处理和边缘情况覆盖
编写更全面的测试用例
备注
API已开发完成并可以通过以下命令测试：

bash

Copy
# 测试抖音视频提取
curl -X POST "http://localhost:8000/api/media/extract" \
  -H "Content-Type: application/json" \
  -H "x-source: test-client" \
  -H "x-app-id: test-app" \
  -H "x-user-uuid: test-user" \
  -d '{"url": "https://www.douyin.com/video/7454208045808225595", "extract_text": true}'







关注公众号：判断表里是否有当前用户（meta_user），没有用户向表里新增一条用户数据
点击公众号菜单-领取限时积分：
	如果没关注公众号（库里没有当前用户），提醒需要先关注公众号，
	如果关注过公众号（库里有当前用户信息），
		判断是否领过限时积分 (当前用户在表里rel_points_transaction是否有related_product_id为一个临时送积分产品的关系数据，
			产品表里放一个过期时间为3天的100积分售价为0 的产品)
			如果领过，提示用户当前用户已经领过 过期时间是 几月几日，100积分的产品，记录日志
				提醒用户会不定时发放0元购积分包，请随时关注；
				记录日志；
			如果没领过，在添加用户在 rel_points_transaction 表里相关记录，remark里标注是 什么时间用户在公众号 通过哪个产品 领取几号过期的 多少积分；
					更新 meta_user_points 表当前用户信息；
					更新 用户表 是否有积分的 信息；
					提熊用户 创建自己的 api key;
					记录日志；
点击公众号菜单- 查看 api-key：
	如果没关注公众号（库里没有当前用户），提醒需要先关注公众号，
	如果关注过公众号（库里有当前用户信息）
		将当前用户在 meta_auth_key 里创建的 api key 列出来
点击创建 api-key :
	如果没关注公众号（库里没有当前用户），提醒需要先关注公众号，
	如果关注过公众号（库里有当前用户信息）
		引导起个名字，在 meta_auth_key 里创建默认一个月 的 api key ，将 值返回；
		


原来的auth_key_checker文件里的 _check_call_limit_exceeded 和_update_call_count 方法是 以api_key为基准进行检查和递增
现在我们判断用户传递来的api_key 是否能使用 api 的逻辑做了变更，
变更为 api_key只是负责验证用户是否有权限

_check_call_limit_exceeded
新判断逻辑是 使用 meta_user 用户表 
判断用户是否有积分、如果没有积分就报错，提示没有积分，没有积分自然没法使用 api;
如果有积分就去 meta_user_points 获取当前用户 可用积分,如果积分大于0，就存入上下文，如果等于0，就报错，提示积分不足，积分不足自然没法使用 api;
如果有大于0的积分，就继续执行，等待宿主方法执行完，
如果执行成功，
和_update_call_count 新逻辑变更为：
从上下文中获 本次取消耗积分的值 ，将消耗行为 存入 rel_points_transaction表，更新 meta_user_points 表 



以调用 media 的extract为例，
调用成功的情况下，在提取文案信息时判断时间长度，每60秒钟扣10 积分，不足60秒，扣10分，例如 100秒 扣 2 * 10分，
获取音频时间长度之后，从上下文判断用户剩余积分-改扣之后是否大于0，
如果小于0 ，应该报错提示用户积分不足，写清楚需要消耗多少，只剩多少，让用户去充值;
如果大于0且执行成功，则将消耗积分存入上下文，供后续_update_call_count获取执行扣减，如果大于0 但是后续执行失败，不应该扣分，记录日志；
